import os
from os.path import join, isdir

import numpy as np
import nibabel as nib
import torch

def load_weights_infer(checkpoint_path, model):
    """
    Loads pytorch model from a checkpoint and into inference mode.

    Args:
        checkpoint_path (str): path to a .pt or .pth checkpoint
        model (torch.nn.Module): <-
    Returns:
        Model with loaded weights and in evaluation mode
    """
    try:
        # catalyst weights
        state_dict = torch.load(checkpoint_path, map_location="cpu")["model_state_dict"]
    except:
        # anything else
        state_dict = torch.load(checkpoint_path, map_location="cpu")
    try:
        model.load_state_dict(state_dict, strict=True)
    except:
        # for clf + seg for seg only prediction
        print(f"Non-strict loading of weights from {checkpoint_path}")
        model.load_state_dict(state_dict, strict=False)
    model.eval()
    return model

def create_submission(pred_dir, out_dir, orig_dir, cases=None):
    """
    Creates a submission directory from the predictions. To complete the
    submission, run this from command prompt:
    zip predictions.zip out_dir/predictions/prediction_*.nii.gz;
    change out_dir to whatever out_dir you specified for this function.
    Args:
        pred_dir: file path to the predictions directory, generated by
            infer.Predictor
        out_dir: file path to the directory where the predictions.zip is to
            be saved.
        orig_dir: file path to the original image directory (kits19/data).
        cases (iterable): iterable of case folder names
    """
    # setting up the output directory
    out_pred_dir = join(out_dir, "predictions")

    if not isdir(out_pred_dir):
        os.mkdir(out_pred_dir)
        print("Created directory: {0}".format(out_pred_dir))

    if cases is None:
        cases = ["case_{:05d}".format(i) for i in range(210, 300)]

    # iteratively converting each prediction
    for (i, case) in enumerate(cases):
        print("Processing {0}/{1}: {2}".format(i+1, len(cases), case))
        x_nib = nib.load(join(orig_dir, case, "imaging.nii.gz"))
        pred = np.load(join(pred_dir, case, "pred_{0}.npy".format(case)))
        # converting the prediction to a .nii.gz file
        p_nib = nib.Nifti1Image(pred, x_nib.affine)
        id_ = case[-5:] # number id attached to each case
        out_fpath = join(out_pred_dir, "prediction_{0}.nii.gz".format(id_))
        nib.save(p_nib, out_fpath)

    for case in tqdm(self.cases):
        x_nib = nib.load(join(orig_dir, case, "imaging.nii.gz"))
        pred = np.load(join(pred_dir, case, f"pred_{case}.npy"))
        # converting the prediction to a .nii.gz file
        p_nib = nib.Nifti1Image(pred, x_nib.affine)
        id_ = case[-5:] # number id attached to each case
        out_fpath = join(out_pred_dir, f"prediction_{id_}.nii.gz")
        nib.save(p_nib, out_fpath)
